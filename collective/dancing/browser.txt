Browser tests
=============

These are browser-driven tests for the functionality provided by the
``collective.dancing`` package.

Setup
-----

  >>> from Testing.ZopeTestCase import user_password
  >>> from Products.Five.testbrowser import Browser
  >>> def new_browser():
  ...     browser = Browser()
  ...     browser.handleErrors = False
  ...     return browser
  >>> browser = new_browser()

  >>> from collective.dancing.tests import setup_error_log
  >>> print_error = setup_error_log(portal)

We want messages to be printed out instead of sending them:

  >>> from zope import interface, component
  >>> import zope.sendmail.interfaces

  >>> class MyMailDelivery(object):
  ...     interface.implements(zope.sendmail.interfaces.IMailDelivery)
  ...     sent = []
  ...
  ...     def send(self, from_, to, message):
  ...         print 'MyMailDelivery sending:'
  ...         print 'From:', from_
  ...         print 'To:', to
  ...         print 'Message follows:'
  ...         print message
  ...         self.sent.append(message)

  >>> component.provideUtility(MyMailDelivery())

Control panel
-------------

The ``collective.dancing`` package registers a control panel; we can
reach it as an administrator through the 'Site Setup' link:

  >>> browser.addHeader('Authorization',
  ...                   'Basic %s:%s' % ('portal_owner', user_password))
  >>> browser.open(portal.absolute_url())
  >>> browser.getLink('Site Setup').click()
  >>> browser.getLink('Newsletters').click()
  >>> browser.url
  'http://nohost/plone/portal_newsletters'
  >>> "Newsletter configuration" in browser.contents
  True

Channels administration
-----------------------

The admistration screen can be reached through Plone control panel:

  >>> browser.getLink('Newsletter channels administration').click()

Through this administration screen we can add and delete channels:

  >>> browser.getControl('Title').value = 'My channel'
  >>> browser.getControl('Add').click()
  >>> 'Item added successfully' in browser.contents
  True
  >>> 'My channel' in browser.contents
  True 
  >>> browser.getControl('Title').value = 'My other channel'
  >>> browser.getControl('Add').click()
  >>> 'Item added successfully' in browser.contents
  True

Let's delete the first of the two channels:

  >>> btn = browser.getControl(name='crud-edit.my-channel.widgets.select:list')
  >>> btn.value = ['selected']
  >>> browser.getControl(name='crud-edit.buttons.delete').click()
  >>> "Successfully deleted items" in browser.contents
  True
  >>> 'My channel' in browser.contents, 'My other channel' in browser.contents
  (False, True)

The default "Latest news" collector is already selected for our
channel:

  >>> collector = browser.getControl(
  ...     name='crud-edit.my-other-channel.widgets.collector:list')
  >>> collector.displayValue
  ['Latest news']

Configuring collectors
----------------------

We can click on "Latest news" to configure what items go into the
channel:

  >>> browser.getLink('Latest news').click()

Here, we'll find a link to the Smart Folder that's used to filter and
sort the items that go into the channel.  Thus, we click another time
to interact with the Smart Folder interface:

  >>> browser.getLink('edit the Smart Folder').click()

Let's say we wanted the channel to contain both News Items and Events.
We'll add to the selection the Events type and save:

  >>> types = browser.getControl(
  ...     name='crit__Type_ATPortalTypeCriterion_value:list')
  >>> types.value = ['News Item', 'Event']
  >>> browser.getControl(name='form.button.Save').click()
  >>> "Changes saved" in browser.contents
  True

Okay, so now we catch both events and news items throughout the site.
To see if that's true, we'll create two items, one for each type:

  >>> news = portal.news
  >>> workflow = portal.portal_workflow
  >>> self.loginAsPortalOwner()
  >>> news.invokeFactory(
  ...     'News Item', id='flu', title='Drug-resistant flu rising, says WHO')
  'flu'
  >>> workflow.doActionFor(news['flu'], 'publish')

  >>> events = portal.events
  >>> events.invokeFactory('Event', id='super-bowl', title='Super Bowl XLII')
  'super-bowl'
  >>> workflow.doActionFor(events['super-bowl'], 'publish')

We can now expect these two items to show up when we look at the
collector's Smart Folder's RSS view:

  >>> browser.open(browser.url.rsplit('/', 1)[0] + '/RSS')
  >>> 'Super Bowl XLII' in browser.contents, 'flu rising' in browser.contents
  (True, True)

For e-mail subscriptions to this channel, we'll allow subscribers to
choose which content types they're interested in; whether it's news
items, events, or both.  The default will be both.

We'll mark the "Portal Types Criterion" as restrictable by the
subscriber.  The collector edit form allows us to do this:

  >>> browser.goBack()
  >>> browser.getLink('Latest news').click()
  >>> criteria = browser.getControl("Select content types").click()
  >>> browser.getControl('Apply').click()
  >>> "Data successfully updated" in browser.contents
  True

Channel subscriptions
---------------------

Going back to the channel administration screen, we can click on the
channel's name to reach the channel subscriptions screen:

  >>> browser.open(portal.absolute_url() + '/portal_newsletters/channels')
  >>> browser.getLink('My other channel').click()

We can add new subscriptions here:

  >>> browser.getControl('E-mail address').value = u"daniel@localhost"
  >>> browser.getControl('Add').click()
  >>> 'Item added successfully' in browser.contents
  True
  >>> 'daniel@localhost' in browser.contents
  True

We'll add another subscription.  This one filters on the content type:

  >>> browser.getControl('E-mail address').value = u"mailman@localhost"
  >>> browser.getControl('News Item', index=1).click()
  >>> browser.getControl('Add').click()
  >>> 'Item added successfully' in browser.contents
  True

  >>> print browser.contents # doctest: +ELLIPSIS
  <!DOCTYPE...daniel@localhost...
  ...mailman@localhost...value="News Item" checked="checked" />...

Stats
-----

Also the statistics screens can be reached through the control panel:

  >>> browser.open('http://nohost/plone/portal_newsletters')
  >>> browser.getLink('Newsletter statistics').click()

We can see that our channel is listed here:

  >>> print browser.contents # doctest: +ELLIPSIS
  <!DOCTYPE...My other channel...0...0...0...0...0...

We can create a message now and see how the statistics reflect this.
First, let's get a hold of our subscription object:

  >>> channel = portal.portal_newsletters.channels.objectValues()[0]
  >>> subscription = channel.subscriptions.values()[0][0]
  >>> subscription # doctest: +ELLIPSIS
  <collective.singing.subscribe.SimpleSubscription object ...>

We can now queue a new message:

  >>> from collective.singing import message
  >>> message.Message(payload=u"Hello, World!", subscription=subscription) \
  ... # doctest: +ELLIPSIS
  <collective.singing.message.Message object ...>

Et voila:

  >>> browser.reload()
  >>> print browser.contents #doctest: +ELLIPSIS
  <!DOCTYPE...My other channel...0...1...0...0...0...

The statistics screen allows us to also send queued messages.  Right
now, noone knows how to send text messages like the one we just
created.  We'll register an adapter to do that for us:

  >>> import collective.singing.interfaces

  >>> class MyTextDispatch(object):
  ...     interface.implements(collective.singing.interfaces.IDispatch)
  ...     component.adapts(unicode)
  ... 
  ...     failure = False
  ... 
  ...     def __init__(self, message):
  ...         self.message = message
  ... 
  ...     def __call__(self):
  ...         if self.failure:
  ...             return u'error', self.failure
  ...         print "Sending %r" % self.message
  ...         return u'sent', None

  >>> component.provideAdapter(MyTextDispatch)

Now we can select our channel and click the "Send messages now" button:

  >>> btn = browser.getControl(
  ...     name='crud-edit.my-other-channel.widgets.select:list')
  >>> btn.value = ['selected']
  >>> browser.getControl('Send messages now').click()
  Sending u'Hello, World!'
  >>> "1 message(s) sent" in browser.contents
  True

If sending the message fails, we'll get notified:

  >>> message.Message(payload=u"Hello, Aliens!", subscription=subscription) \
  ... # doctest: +ELLIPSIS
  <collective.singing.message.Message object ...>

  >>> MyTextDispatch.failure = u'Sorry, failed'
  >>> btn = browser.getControl(
  ...     name='crud-edit.my-other-channel.widgets.select:list')
  >>> btn.value = ['selected']
  >>> browser.getControl('Send messages now').click()
  >>> "1 failure(s)" in browser.contents
  True
  >>> "0 message(s) sent" in browser.contents
  True

Subscribe
---------

Every channel has a view that allows people to subscribe:

  >>> browser = new_browser()
  >>> browser.open(channel.absolute_url() + '/subscribe.html')
  >>> "My other channel" in browser.contents
  True

We'll subscribe to events only:

  >>> browser.getControl('E-mail address').value = u"root@localhost"
  >>> browser.getControl('Event').click()
  >>> browser.getControl('Finish').click() \
  ... # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
  MyMailDelivery sending:
  From: Site Administrator <>
  To: root@localhost
  Message follows:
  ...
  To confirm your subscription with My other channel, please click here:...
  
  >>> "Thanks for your subscription" in browser.contents
  True

  >>> import quopri
  >>> msg = quopri.decodestring(MyMailDelivery.sent[-1])
  >>> confirm_url = "http://nohost/plone/portal_newsletters/channels/my-other-channel/confirm-subscription.html"
  >>> confirm_url + "?secret=" in msg
  True
  >>> secret = msg[msg.rindex('secret='):msg.index('</a')]
  >>> secret.startswith('secret=')
  True

So now we've received an e-mail to confirm our subscription.  Snooping
around in the list of subscribers, we can see that our subscription is
*pending*:

  >>> from collective.singing.interfaces import (
  ...     ISubscriptionMetadata, IComposerData)
  >>> subscription = channel.subscriptions[secret.split('=')[1]][0]
  >>> ISubscriptionMetadata(subscription)['pending']
  True
  >>> dict(IComposerData(subscription))
  {'email': u'root@localhost'}

After confirming our subscription, the subscription is no longer
pending:

  >>> browser.open(confirm_url + '?' + secret)
  >>> "You confirmed your subscription successfully" in browser.contents
  True
  >>> ISubscriptionMetadata(subscription)['pending']
  False

Trying to confirm a subscription that doesn't exist will give us a
meaningful message:

  >>> browser.open(confirm_url + '?secret=imfake')
  >>> "Your subscription isn't known to us" in browser.contents
  True

Unsubscribe
-----------

For this, we'll quickly add another subscription:

  >>> browser.open(channel.absolute_url() + '/subscribe.html')
  >>> browser.getControl('E-mail address').value = u"daemon@localhost"
  >>> browser.getControl('Finish').click() \
  ... # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
  MyMailDelivery sending:
  From: Site Administrator <>
  To: daemon@localhost...

  >>> msg = quopri.decodestring(MyMailDelivery.sent[-1])
  >>> secret = msg[msg.rindex('secret='):msg.index('</a')]
  >>> browser.open(confirm_url + '?' + secret)
  >>> "You confirmed your subscription successfully" in browser.contents
  True

Now let's unsubscribe:

  >>> browser.open(channel.absolute_url() + '/unsubscribe.html?' + secret)
  >>> "You unsubscribed successfully" in browser.contents
  True

We're now no longer subscribed:

  >>> browser.open(channel.absolute_url() + '/unsubscribe.html?' + secret)
  >>> "You aren't subscribed to this channel" in browser.contents
  True

Using a scheduler to send e-mails
---------------------------------

The default scheduler for channels is the weekly scheduler:

  >>> channel.scheduler
  <WeeklyScheduler at /plone/portal_newsletters/channels/my-other-channel/scheduler>

Calling the scheduler's ``tick`` method will send messages to all our
subscribers.  Right now the scheduler is inactive though, i.e. it
won't trigger, ever:

  >>> channel.scheduler.tick(channel)

Let's make it active.  Now we can see that the messages are being
sent:

  >>> channel.scheduler.active = True
  >>> channel.scheduler.tick(channel)
  blabla

Doing it a second time won't do anything:

  >>> channel.scheduler.tick(channel)

This has two reasons really: Firstly, the scheduler keeps track of
when it queued something the last time:

  >>> import datetime
  >>> now = datetime.datetime.now()
  >>> channel.scheduler.triggered_last < now
  True
  >>> now - datetime.timedelta(hours=1) < channel.scheduler.triggered_last
  True

Secondly, all our subscriptions have a "cue" set, which marks the time
when they last received an item:

  >>> subscriptions = []
  >>> for subs in channel.subscriptions.values():
  ...     subscriptions.extend(subs)
  >>> mds = [interfaces.ISubscriptionMetadata(s) for s in subscriptions]
  >>> [md['cue'] for md in mds]
  [foo, bar, baz]

We have to reset *both* the cues and the ``triggered_last`` time for
messages to be queued again:

  >>> for md in mds:
  ...     del md['cue']
  >>> channel.scheduler.tick(channel)

  >>> channel.scheduler.triggered_last = datetime.datetime(1, 1, 1, 0, 0)
  >>> channel.scheduler.tick(channel)
  blabla

We can choose another scheduler for our channel by visiting the
channel administration screen:

  >>> browser.addHeader('Authorization',
  ...                   'Basic %s:%s' % ('portal_owner', user_password))
  >>> browser.open(channel.absolute_url())
  >>> select = browser.getControl(
  ...     name='crud-edit.my-other-channel.widgets.scheduler:list')
  >>> select.value = ['Weekly Scheduler']
  >>> browser.getControl('Apply').click()
  >>> "Data successfully updated" in browser.contents
  True

That's right!  We're keeping the same scheduler.  Thus, another tick
won't do anything, because the ``triggered_last`` date is preserved:

  >>> channel.scheduler.tick(channel)

Let's select the daily scheduler now:

  >>> select = browser.getControl(
  ...     name='crud-edit.my-other-channel.widgets.scheduler:list')
  >>> select.value = ['Daily Scheduler']
  >>> browser.getControl('Apply').click()
  >>> "Data successfully updated" in browser.contents
  True

Again, that scheduler is inactive by default.  Also, the subscriptions
still have their cues set:

  >>> channel.scheduler.tick(channel)
  >>> for md in mds:
  ...     del md['cue']
  >>> channel.scheduler.tick(channel)

We can visit the scheduler's management screen to activate it:

  >>> browser.getLink('Daily scheduler').click()
  >>> "Daily scheduler for My other channel" in browser.contents
  True
  >>> browser.getControl('Active').click()
  >>> browser.getControl('Apply').click()
  >>> "Data successfully updated" in browser.contents
  True

The scheduler will send messages now:

  >>> channel.scheduler.tick(channel)
  blabla
